---
layout: post 
category: CSAPP 
---
---

#### 当我们使用循环时，我们想要程序干什么？

**自动化地完成循环体代码制定的一系列操作，并自动检查循环退出条件**

其中循环体中的所有操作是无法避免的、是必须要做的操作（虽然无法避免，但是可以设法提高其并行性）

而检查循环退出条件、更新循环变量（i++）是为了实现循环的自动化而支付的代价

---

循环展开就是对上述两点进行优化

- 让循环体内部的代码更集中，部分情况下可以提高代码的并行性。比如**拥有多个ALU的CPU**运行计算阶段需要多个时钟周期的指令时。例如<br>代码段A：`for(int i = 1;i<n;++i){a[i] *= b[i]}`<br>代码段B:`for(int i = 1;i<n;i+=2){a[i] *= b[i],a[i+1] *= b[i+1]}`<br>代码段B可以并行地运行循环体当中没有相关性的两条乘法指令，提高指令级的并行性

- 减少不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支

---

y86处理器只有一个ALU、假设所有指令的每个阶段都能在一个时钟周期内完成，是一个非常简化的处理器，对于这种情况，循环展开主要发挥上述的第二个作用：**减少不有助于程序结果的操作的数量**

我们需要实现的功能是将n个long型变量从内存位置1复制到内存位置2，并且统计大于0的变量的个数

当不使用循环展开时，<font color=red>不有助于程序结果的操作</font>的数量级大约是<font color=red>n</font>，有n个元素就要进行n轮循环，每轮循环支付一次代价

当使用k路循环展开时，<font color=red>不有助于程序结果的操作</font>的数量级大约是<font color=red>n/k+k</font>，每轮循环计算k个元素，需要n/k轮循环，每轮循环支付一次代价；循环完毕后还可能剩余最多k-1个元素，最简单的处理方式就是通过一个步长为1的循环操作剩余的元素

**在实验中主要着手减少对于剩余元素支付的代价**

我们之所以要用循环处理剩余元素，是因为不知道剩余元素的具体个数，只能利用循环设置自动化的循环退出条件

一旦我们能确定最终剩余的有限个（0~k-1个）元素的具体数量，就可以使用静态的代码完成处理，而不必支付循环的代价

如果是x86处理器，我们本不必考虑那么多，因为可以使用类似于switch语句优化为switch跳转表的方式，通过剩余元素数量，进行间接跳转，O(1)的时间跳到处理具体元素数目的代码。**但是y86处理器不允许间接跳转！**

所以，我们**使用二叉树搜索剩余元素的个数**，即用O(log k)的时间代价，跳转到处理具体元素数目的代码

优化后，k路循环展开<font color=red>不有助于程序结果的操作</font>的数量级大约是<font color=red>n/k+log k</font>。循环展开的路数<font color=red>k</font>越多，<font color=red>n/k</font>越小，而<font color=red>log k</font>的增长非常缓慢，有了这样的处理方式，我们基本可以认为循环展开的路数越多，实验得分就越高。所以实验才设置了代码字节数小于1000字节的限制。
