---
layout: post 
category: papers 
---
---
为了优化小容量键值对无法充分使用持久化内存（persistent memory,PM）带宽的问题，提出了FlatStore。将传统键-值存储解耦为以高效存储为目的的持久化日志结构和以快速索引为目的的非持久化索引。

- 压缩日志结构以提高并行性
- 流水线水平批处理，在创建批处理时从其他核心窃取日志条目，从而提供低延迟和高吞吐量性能

---

重点：**如何设计高效的键值存储来处理写密集型和小型的工作负载**

问题：当前很多种kv存储访问模式的粒度和持久化内存不匹配。当前的kv存储系统会生成巨多的小体积写，很大比例的k-v对包含很小的应用工作负荷（10字节左右）。此外，kv存储的索引结构导致了巨大的写放大。CPU以cacheline的粒度（64B in AMD adn x86 platform）刷新数据，但是PM的内部块(256 B in Optane DCPMM)更大，显著浪费了硬件带宽。

本文在傲腾持久化内存上部署了一个持久化的KV索引

经典的方法是使用日志化结构组织kv存储，然后所有更新只需要添加到日志，还可以批处理来自客户端的多个请求分摊开销。这个想法在HDD和SSD上运行地很好因为他们有很好的顺序写性能，每一次写的吞吐量可以很大（up to tens of MBs)。但是在NVM-based系统上不太行：

- 只要I/O大小比最小的I/O单元（i.e. 256B block size）大，并且有足够多的并发I/O，傲腾持久内存有非常相似的访问速度，所以无法通过批处理存储器访问来提高性能。并且持久化内存的访问粒度更小（i.e., 64 B flush size and 256 B block size），如果我们把所有对存储器的更新都放在日志里面，那么一次访问内存只能得到很有限的日志条目。

- 批量处理有明显的延迟，当前的非易失性内存和高速网卡都主打低延迟，那么传统的批量处理就不太合适。对多核处理器也不友好

<font color="grey">我的理解：leveldb在内存中维护一个跳表，直到它足够大就dump到磁盘中实现持久化，这样做可以将批量的小磁盘I/O转化为一个大的连续写，这样对于机械硬盘和传统SSD是有加速效果的，但是对于NVM没什么效果，而且还会导致延迟，所以作者要找一个新方法。</font>

将kv存储分为两个部分：

- 易失性的索引（为了提高索引速度）
- 持久化日志结构（为了提高存储效率）

**紧凑日志格式**和**流水线水平批处理**实现高吞吐量，低延迟和多核可扩展性

---

当今工业上对数据库的需求从读密集转向写密集，并且大部分数据库条目并不大。

对数据库的小更新和持久化数据的粒度不匹配

傲腾可持久化内存的几个特点

- 顺序和随机访问在高并发的条件下有相似的带宽
- 重复刷新到相同的缓存行有巨大延迟（对于就地更新不友好）
  - clwb指令是异步执行的，后面的clwb指令要等前面的执行完
  - 傲腾内存的片上防止磨损机制可能阻止了同一个缓存行上后续的刷新

---

FlatStore 的设计原则

- 最小化写开销
- 低延迟
- 多核可拓展性

![image-20211003112145878](../../www/assets/pic/image-20211003112145878.png)

核心组件：

- 压缩的操作日志（Compacted OpLog）FlatStore incorporates a per-core log-structured OpLog to absorb frequent and small-sized updates with efficient batching.

- 惰性持续分配器（Lazy-persist Allocator）。为存储大型kv对打造，由于OpLog已经记录了大型kv的地址，不再需要刷新相同的元数据（位图）。

- 流水线水平批处理（Pipelined Horizontal Batching）。允许核心在创建批处理时从其他核心窃取日志条目

为了加速检索，在DRAM中存储额外的易失性索引副本

---

**Compacted OpLog and Lazy-Persist Allocator**

如前所述，在持久键值存储中更新通常会导致巨大的写入放大和缓存冲洗。

<font color="grey">什么是缓存冲洗（flush）？ 当高速缓存中的未写入数据量达到一定级别时，控制器周期性地将高速缓存的数据写入驱动器。 这个写入过程称为“冲洗”。 控制器使用两个算法进行刷新缓存：基于需求和基于年龄的算法</font>

为解决这个问题，FlatStore将kv存储拆分为：

- 易失性索引
- 压缩的、每个核心的OpLog处理小更新，持久化分配器存储大kv对

当执行一个更新请求时，处理器核心仅写键值，将一个日志条目加到它的本地日志末尾然后更新易失性索引。因此，避免了散列索引重新哈希或者树形索引移位/分裂/合并而引起的持久化开销。要服务于GET请求，服务器核心首先引用带给定键的易失性索引来查找键值项以查找确切的日志条目，最后得到键值项。以这种方式，扫描整个日志以找到特定键的开销也被避免。

**日志条目的压缩**，Oplog的一个关键设计方面是如何构建日志条目的布局：日志条目应该设计足够小以更好地支持批处理，使得可以在一次flush操作中持久化更多的条目。因此，仅将索引元数据和极小的kv项放到OpLog中（在我们的实现中，256 B足以使Optane DCPMM的带宽饱和）然后其他的大型kv项目由一个分配器单独存储。同时，每个日志条目还需要在运行时包含足够的元数据以供运行期间的正常索引并且在系统崩溃后安全地恢复丢失的易失性索引结构。

