---
layout: post 
category: CSAPP 
---

---

## 基于线程的并发编程

线程就是运行在进程上下文中的逻辑流

线程由内核自动调度

每个线程有自己的线程上下文（唯一整数线程ID->内核用他识别线程、栈、栈指针、程序计数器、通用目的寄存器、条件码）

所有运行在一个进程里的线程共享该进程的整个虚拟地址空间（包括代码、数据、堆、共享库和打开的文件）

线程不像进程一样使用严格的父子层次来组织，和一个**进程**相关的**线程**组成一个对等线程池，独立于其他线程创建的线程。

主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。

每个对等线程都能读写相同的共享数据。

---

在编写多线程程序时，我们通过定义宏_REENTRANT来告诉编译器我们需要可重入功能。编译器会执行三件事：

对部分函数重新定义它们的可安全重入版本

stdio中原来以宏的形式实现的一些函数将变成安全可重入的形式

在errno.h中定义的变量errno现在将成为一个函数调用，以多线程安全的方式获取errno的值

**线程需要添加gcc参数-pthread，如果你使用cmake，需要在CMakeLists.txt添加set(CMAKE_EXE_LINKER_FLAGS "-pthread")**

### 线程库提供的函数

```c
#include <pthread.h>

/// 创建一个新线程 Compile and link with -pthread.
/// \param thread 一个指向pthread_t类型数据的指针，
/// 线程被创建时，该指针指向的变量中将写入一个标识符，
/// 用这个标识符来引入新线程
/// \param attr 设置线程的属性，不需要特殊属性就是NULL
/// \param start_routine 将要启动的执行函数
/// \param arg 传递给该函数的参数
/// \return 成功返回0,错误返回错误代码
int pthread_create(pthread_t *restrict thread,
                   const pthread_attr_t *restrict attr,
                   void *(*start_routine)(void *),
        // start_routine是一个指针，
        // 这个指针指向一个函数
        // 这个函数以一个void*类型（指向void的指针）的值为参数
        // 返回一个指向void的指针
                   void *restrict arg);

#include <stdnoreturn.h>
/// 终止调用它的线程并返回指向某个对象的指针
/// 绝不能返回指向某个局部变量的指针，因为线程调用该函数后，局部变量就不存在了
/// 事实上，这样返回是可以的：
/// pthread_exit("Thank you for the CPU time.");
/// 这样返回是错误的：
/// char x[] = "return val";
/// pthread_exit(x);
/// \param retval
noreturn void pthread_exit(void *retval);

/// 等价与进程中用来收集子进程信息的wait函数
/// \param thread 指定要等待的线程
/// \param retval 一个指向指针的指针，被指向的这个指针就是线程的返回值
/// \return 成功返回0错误返回错误码
int pthread_join(pthread_t thread, void **retval);
```

### 最简单的多线程例子

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

char message[] = "Hello World";

void *thread_function(void *arg) {
    printf("thread_function is running. Argument was %s\n", (char *) arg);
    sleep(3);
    strcpy(message, "Bye!");
    pthread_exit("Thank you for the CPU time.");
}

int main() {
    int res;
    pthread_t a_thread;
    void *thread_result;
    res = pthread_create(&a_thread, NULL, thread_function, (void *) message);
    if (res != 0) {
        perror("THread creation failed");
        exit(EXIT_FAILURE);
    }
    printf("Waiting for thread to finish\n");
    res = pthread_join(a_thread, &thread_result);
    if (res != 0) {
        perror("Thread join failed");
        exit(EXIT_FAILURE);
    }
    printf("Thread joined. it returned %s\n", (char *) thread_result);
    printf("Message is now %s\n", message);
    exit(EXIT_SUCCESS);
}
```

#### 输出：

```c
Waiting for thread to finish
thread_function is running. Argument was Hello World
Thread joined. it returned Thank you for the CPU time.
Message is now Bye!

进程已结束，退出代码为 0
```

### 分离线程

可结合的线程可以被其他线程收回和杀死，线程默认都是可结合的，为避免内存泄露，每个可结合线程都应该被其他线程显式收回。

可以通过pthread_detach函数分离线程，使这个线程不能被其他线程回收或杀死，他的内存资源在终止时由系统自动释放

对于主线程没有必要显式等待每个线程终止的情况，就应该分离线程

```c
/// 分离线程
/// \param thread 指定要分离的线程，
/// 线程可以通过以pthread_self()为参数分离自己
/// \return 成功返回0错误返回错误码
int pthread_detach(pthread_t thread);
```

### 初始化线程

```c
/// 初始化与线程例程相关的状态
/// 第一次用参数once_control调用pthread_once时，
/// 它调用init_routine (一个没有输入参数也不返回什么的函数)
/// 接下来以参数once_control调用pthread_once时不做任何事情
/// \param once_control
/// \param init_routine
/// \return
int pthread_once(pthread_once_t *once_control,
                 void (*init_routine)(void));
//一个全局变量或静态变量，总是被初始化为PTHREAD_ONCE_INIT
pthread_once_t once_control = PTHREAD_ONCE_INIT;
```

