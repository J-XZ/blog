---
layout: post
category: CSAPP
title: 动态链接实践

---

系统版本：Ubuntu 20.04.2 LTS

gcc版本：gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0

gdb版本：GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2

gdbgui版本：0.14.0.2

---

首先准备两个文件，放在同一个文件夹中。

```c
//main.c
extern int num1;
extern int getnum2();
int main()
{
	int a = num1;
	int b = getnum2();
	return a + b;
}
```

```c
//num.c
int num1 = 16;
int getnum2()
{
	return 26;
}
```

使用**gcc**将**num.c**编译为**位置无关**的动态链接库**num.so**：

```bash
gcc -g -shared -fPIC num.c -o num.so
```

- 参数`-shared`表示这是一个共享库
- `-fPIC`表示编译为一个位置无关的代码

编译**main.c**使它可与**num.so**动态链接

```bash
$ gcc -g main.c ./num.so -o main
```

给定动态链接库参数时，必须写成`./num.so`，否则会找不到动态链接库。

使用命令`ldd`查看可执行文件main依赖的动态链接库

```bash
$ ldd main
	linux-vdso.so.1 (0x00007ffde804e000)
	./num.so (0x00007f4d203c4000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4d201bb000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f4d203d0000)
```

使用file命令查看main的文件类型

```bash
$ file main
main: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c4d9f3689c2399255fb18b1ca6805d3f03f431ac, for GNU/Linux 3.2.0, with debug_info, not stripped
```

查看main的sections

```bash
$ readelf --sections ./main
There are 36 section headers, starting at offset 0x4258:

节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338
       0000000000000020  0000000000000000   A       0     0     8
  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0
       0000000000000028  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8
       00000000000000d8  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           00000000000004a0  000004a0
       000000000000009a  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           000000000000053a  0000053a
       0000000000000012  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          0000000000000550  00000550
       0000000000000020  0000000000000000   A       7     1     8
  [10] .rela.dyn         RELA             0000000000000570  00000570
       00000000000000d8  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             0000000000000648  00000648
       0000000000000030  0000000000000018  AI       6    24     8
  [12] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000001020  00001020
       0000000000000030  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000001050  00001050
       0000000000000010  0000000000000010  AX       0     0     16
  [15] .plt.sec          PROGBITS         0000000000001060  00001060
       0000000000000020  0000000000000010  AX       0     0     16
  [16] .text             PROGBITS         0000000000001080  00001080
       00000000000001a5  0000000000000000  AX       0     0     16
  [17] .fini             PROGBITS         0000000000001228  00001228
       000000000000000d  0000000000000000  AX       0     0     4
  [18] .rodata           PROGBITS         0000000000002000  00002000
       0000000000000008  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002008  00002008
       0000000000000044  0000000000000000   A       0     0     4
  [20] .eh_frame         PROGBITS         0000000000002050  00002050
       0000000000000108  0000000000000000   A       0     0     8
  [21] .init_array       INIT_ARRAY       0000000000003da0  00002da0
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .fini_array       FINI_ARRAY       0000000000003da8  00002da8
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .dynamic          DYNAMIC          0000000000003db0  00002db0
       0000000000000200  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000003fb0  00002fb0
       0000000000000050  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000004010  00003010
       0000000000000008  0000000000000000  WA       0     0     8
  [27] .comment          PROGBITS         0000000000000000  00003010
       000000000000002a  0000000000000001  MS       0     0     1
  [28] .debug_aranges    PROGBITS         0000000000000000  0000303a
       0000000000000030  0000000000000000           0     0     1
  [29] .debug_info       PROGBITS         0000000000000000  0000306a
       0000000000000328  0000000000000000           0     0     1
  [30] .debug_abbrev     PROGBITS         0000000000000000  00003392
       00000000000000dd  0000000000000000           0     0     1
  [31] .debug_line       PROGBITS         0000000000000000  0000346f
       0000000000000116  0000000000000000           0     0     1
  [32] .debug_str        PROGBITS         0000000000000000  00003585
       000000000000029f  0000000000000001  MS       0     0     1
  [33] .symtab           SYMTAB           0000000000000000  00003828
       00000000000006c0  0000000000000018          34    51     8
  [34] .strtab           STRTAB           0000000000000000  00003ee8
       0000000000000211  0000000000000000           0     0     1
  [35] .shstrtab         STRTAB           0000000000000000  000040f9
       000000000000015a  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)

```

查看main中需要重定位的符号

```bash
$ readelf --relocs ./main

重定位节 '.rela.dyn' at offset 0x570 contains 9 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000003da0  000000000008 R_X86_64_RELATIVE                    1160
000000003da8  000000000008 R_X86_64_RELATIVE                    1120
000000004008  000000000008 R_X86_64_RELATIVE                    4008
000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000003ff0  000600000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
000000003ff8  000800000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0
000000004010  000700000005 R_X86_64_COPY     0000000000004010 num1 + 0

重定位节 '.rela.plt' at offset 0x648 contains 2 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000003fc8  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
000000003fd0  000500000007 R_X86_64_JUMP_SLO 0000000000000000 getnum2 + 0

```

可见main本身也生成了一个地址无关代码

---

## 对符号num1的重定位

注意上面显示的要重定位的符号num1的偏移量为000000004010实际上指向.bss  段

```bash
$ readelf -S main | grep 4010 -B 2
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000004010  00003010
```

因为main只是声明变量而且没有初始化，在链接前并不知道是否在外部定义。main只能把这个变量放在.bss段并且暂且假设他为0

还可以观察到num1变量的重定位类型为**R_X86_64_COPY**

num1原本是一个初始化定义为非零的变量，但是装载前**main**却把他放在了用于存放默认初始化的数据的**.bss**段。重定位类型**R_X86_64_COPY**是关键。这个类型的重定位变量是在其他ELF对象中定义的初始化外部对象。

> **R_X86_64_COPY**标识一个对象，该对象的存储由当前ELF对象提供，但其初始值需要从另一个对象复制，
>
> 而**R_X86_64_GLOB_DAT**标识一个对象，该对象的存储由其他ELF对象提供，但其初始值由此提供

**R_X86_64_COPY**类变量的初始值需要记录在动态链接库（num.so）中，因为在构建可执行文件(main)时没有其他地方可以获取它们。原则上，可以在构建可执行文件时将他的值复制到可执行文件中，但这样做会不必要地增加可执行对象的大小(因为无论如何这个值都要在共享库中存储一份)，并且如果共享库修改了变量的值，还需要重新构建可执行文件。

共享库是代码只内存中存储一份，但是数据部分需要在每个使用这个共享库的进程中保留一个副本，所以应当由程序而不是共享库提供这个变量。

使用gdb检查main的反汇编代码：

因为main也是一个地址无关代码，他通过相对当前PC位置的方式对全局变量num1进行寻址

在加载前：

![](../../www/assets/pic/2021-07-21%2022-21-52%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

通过相对当前PC位置（rip寄存器）偏移0x2e95的方式定位num1变量到0x4010处，与上面的讨论结果一致。

在装载过程中，装载器应当负责将num1的实际值放到指定的位置

加载后：

![](../../www/assets/pic/2021-07-21%2022-29-26%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

查看内存位置0x555555558010的值：

![](../../www/assets/pic/2021-07-21%2022-31-51%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

按照小端法，10就是实际变量num1的值16

所以对于**R_X86_64_COPY**类型的由外部共享库定义并初始化的全局变量，是在加载时填充实际值的。

---

## 对符号getnum2()的重定位

直接观察汇编指令了解运行过程

![](../../www/assets/pic/2021-07-21%2023-21-36%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

首先到plt表中寻找getnum2的表项

然后

![](../../www/assets/pic/2021-07-21%2023-23-02%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

plt指示前往got.plt查找getnum2函数的实际位置

内存0x555555557fd0位置存储的就是getnum2的实际位置0x 7f ff f7 fc 30 f9

![](../../www/assets/pic/2021-07-21%2023-26-29%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

下一步即跳转到上述位置：

![](../../www/assets/pic/2021-07-21%2023-27-56%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

就进入了getnum2()函数的入口位置。

---

所以，对于定义在共享库中的函数，程序会先到plt表查找其位置，plt表指示前往got.plt表（也就是got表的一部分）获取实际的函数入口位置。

---

令人非常失望的是，我的系统看起来并不支持延迟加载。或许是我的操作过程中某些参数有误。留待以后再补充。
