---
layout: post 
category: CSAPP 
---
---

## Part A

编写Y86-64代码实现C语言代码给定的功能

链表结构体

```c
/* $begin examples */
/* linked list element */
typedef struct ELE {
    long val;
    struct ELE *next;
} *list_ptr;
```

### 1、求链表元素的和

```c
/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls) {
    long val = 0;
    while (ls) {
        val += ls->val;
        ls = ls->next;
    }
    return val;
}
```

```c
#	sum.ys

#   寄存器
#   rax rbx rcx rdx rsp rbp rsi rdi r8~r14
#   条件码
#   ZF  SF  OF
#   指令集
#   halt    nop     rrmovq  irmovq  mrmovvq
#   subq    addq    andq    xorq
#   jle     jl      je      jne     jge     jg
#   call    ret     qushq   popq

#y86总是从0开始执行
#手动设置程序段的起始位置是0
    .pos 0
    irmovq stack, %rsp # 设置栈顶指针
    rrmovq %rsp,%rbp #设置栈底指针
    call main
    halt

main:
    irmovq ele1, %rdi  
    call sum_list
    ret

#参数 指向链表头结点的指针　%rdi
#返回 链表元素之和　　　　　%rax
#将当前节点的值加到总和里面，然后令指针指向下一个节点
#然后判断指针是否为空（==0），如果非空则重复上一步
sum_list:
loop1:
    mrmovq (%rdi),%rbx
    addq %rbx,%rax
    mrmovq 8(%rdi),%rdi
    andq %rdi,%rdi
jne loop1
    ret

.align 8
ele1:
    .quad 0x00a
    .quad ele2
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0

#必须手动设置栈的位置
.pos 0x1000
stack:

```

![2021-08-08 22-46-56 的屏幕截图](../../www/assets/pic/2021-08-08 22-46-56 的屏幕截图.png)

### 2、递归求链表元素的和

```c
/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls) {
    if (!ls)
        return 0;
    else {
        long val = ls->val;
        long rest = rsum_list(ls->next);
        return val + rest;
    }
}
```

```c
#   寄存器
#   rax rbx rcx rdx rsp rbp rsi rdi r8~r14
#   条件码
#   ZF  SF  OF
#   指令集
#   halt    nop     rrmovq  irmovq  mrmovvq
#   subq    addq    andq    xorq
#   jle     jl      je      jne     jge     jg
#   call    ret     qushq   popq

#y86总是从0开始执行
#手动设置程序段的起始位置是0
    .pos 0
    irmovq  stack,  %rsp # 设置栈顶指针
    rrmovq  %rsp,   %rbp #设置栈低指针
    call    main
    halt

main:
    irmovq  ele1,   %rdi   
    call    rsum_list
    ret

#参数　指向链表头结点的指针　%rdi
#返回　链表元素之和　　　　　%rax
rsum_list:
    #清空存储链表元素和的寄存器
    irmovq  $0,     %rax
    #测试当前rdi指向的链表节点是不是null
    andq    %rdi,   %rdi
    #如果是null直接返回0（返回时rax寄存器存的值就是之前清空的0）
    je      return
    #如果当前指向的节点不是空节点
    #先将当前节点指向的值存到栈中
    mrmovq  (%rdi), %rbx
    pushq   %rbx
    #令指针指向下一个节点
    mrmovq  8(%rdi),%rdi
    #递归调用自身，求下一个节点开头的链表的元素和
    #函数返回后下一个节点开头的链表元素和就存储在rax中
    call    rsum_list
    #恢复局部变量rbx的值，也就是当前节点的值
    popq    %rbx
    #将当前节点的值和之后节点值的和相加，得到整个链表的元素和，
    #存在rax中
    addq    %rbx,   %rax
return:
    ret

.align 8
ele1:
    .quad 0x00a
    .quad ele2
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0

#必须手动设置栈的位置
.pos 0x1000
stack:

```

![](../../www/assets/pic/2021-08-08 22-45-27 的屏幕截图.png)

### 3、拷贝数据并返回异或和

```c
#   sum.ys

#   寄存器
#   rax rbx rcx rdx rsp rbp rsi rdi r8~r14
#   条件码
#   ZF  SF  OF
#   指令集
#   halt    nop     rrmovq  irmovq  mrmovq  rmmovq
#   subq    addq    andq    xorq
#   jle     jl      je      jne     jge     jg
#   call    ret     qushq   popq

#y86总是从0开始执行
#手动设置程序段的起始位置是0
    .pos 0
    irmovq stack, %rsp  #设置栈顶指针
    rrmovq %rsp,%rbp    #设置栈底指针
    call main
    halt

main:
    irmovq ele1, %rdi #源地址
    irmovq dest, %rsi #目标地址
    irmovq $0x6,%rdx  #需要复制6*8=48个字节
    #因为c代码中是用long型变量作为中间值进行内存复制的
    call copy_block
    ret

#参数1    指向源内存地址的指针　      %rdi
#参数2    指向目的内存地址的指针      %rsi
#参数3    复制的8字节数             %rdx
#返回     异或和                   %rax
copy_block:
    # 清空异或和
    irmovq $0x0,%rax
loop:
    irmovq $0x0,%rbx
    subq %rbx,%rdx
    # 将rdx与0比较大小，如果rdx<=0就返回
    jle return
    # 将rdx指向的8个字节存到rbx
    mrmovq (%rdi),%rbx
    # 更新异或和
    xorq %rbx,%rax
    # 将这8个字节存到指定的目的地址
    rmmovq %rbx,(%rsi)
    # 源地址和目的地址指针各自后移一个long型变量
    irmovq $0x8,%rbx
    addq %rbx,%rdi
    addq %rbx,%rsi
    # 记录复制量的变量减1
    irmovq $0x1,%rbx
    subq %rbx,%rdx
    # 回到while循环头部
    jmp loop
return:
    ret


.align 8
ele1:
    .quad 0x00a
    .quad ele2
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0

.align 8
dest:
    .quad 0xffffffffffffffff
    .quad 0xffffffffffffffff
    .quad 0xffffffffffffffff
    .quad 0xffffffffffffffff
    .quad 0xffffffffffffffff
    .quad 0xffffffffffffffff

#必须手动设置栈的位置
.pos 0xfff
stack:
```

![2021-08-08 23-46-44 的屏幕截图](../../www/assets/pic/2021-08-08 23-46-44 的屏幕截图.png)

源指指向的内容

![2021-08-08 23-47-21 的屏幕截图](../../www/assets/pic/2021-08-08 23-47-21 的屏幕截图.png)

用python验证异或和正确：

![2021-08-08 23-40-25 的屏幕截图](../../www/assets/pic/2021-08-08 23-40-25 的屏幕截图.png)
