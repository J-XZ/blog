---
layout: post 
category: rocksdb 
---

column_family.h

此文件包含用于管理列族级别元数据的数据结构列表。

这里声明的类之间的基本关系如下图所示：

![img](../../www/assets/pic/%E4%BD%8D%E5%9B%BE1.png)

DBImpl 保留了一个 ColumnFamilySet，它通过指向每个列族各自的 ColumnFamilyData 对象来引用所有列族。这就是 DBImpl 可以列出和操作所有列族的方式。 

ColumnFamilyHandle也直接指向ColumnFamilyData，这样用户在执行查询时，可以直接找到列族的memtables和Version以及SuperVersion，无需经过ColumnFamilySet。

ColumnFamilySet 间接指向 LSM 树的最新视图（memtables 和 SST 文件列表），而正在进行的操作可能持有对当前或过时的 SuperVersion 的引用，后者又指向一个时间点 LSM 树的视图。这保证了正在操作的 memtables 和 SST 文件不会消失，直到 SuperVersion 的引用计数为 0 并被销毁。

下图说明了可能的引用关系：

![img](../../www/assets/pic/%E4%BD%8D%E5%9B%BE1-16382739323411.png)

在这个例子中，即使当前的 LSM-tree 由 Version A 和 memtable a 组成，也被 SuperVersion 引用，两个旧的 SuperVersion：SuperVersion2 和 Superversion1 仍然存在，分别被一个压缩作业和一个旧的迭代器 Iter1 引用。 

SuperVersion2 包含版本 B、memtable a 和 memtable b； 

SuperVersion1 包含版本 B 和 memtable b（可变）。

因此，防止了版本 B 和 memtable b 被破坏或删除。

---

我的疑问：如果多个版本的数据可以同时存在，如何保证数据一致性呢？

---

ColumnFamilyHandleImpl 是客户端用来访问不同列族的类。它具有非平凡的析构函数，当客户端使用列族完成时会调用它。
