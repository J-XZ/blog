---
layout: post 
category: algorithms 
---
二叉树
- 每个节点最多有两个孩子

二叉搜索树
- 每个节点左子树的所有节点都比根节点小，右子树所有节点都比根节点大

红黑树的退出节点（exit node）
- 一个拥有少于两个孩子的节点

红黑树

- 红黑树首先是一个二叉搜索树
- 每个节点被涂成红色或黑色
- 根节点是黑色的
- 每个红色节点的父节点是黑色的
- 对于任意节点$x$和以$x$为根的子树上的任意两个退出节点$e_1$和$e_2$，从$e_1$到$x$的唯一路径上的黑色节点数量一定同从$e_2$到$x$的唯一路径上的黑色节点数量相同
  - 再增加一条由前面5个条件可以推出的推论：每一个红节点要么没有儿子，要么有两个黑儿子

<img src="../../www/assets/pic/image-20211120105249125.png" alt="image-20211120105249125" style="zoom: 50%;" />

上图中3、7、12、18、25、26节点为exit node，因为每一个都有少于两个孩子。

查询每个节点的时间复杂度都是$O(log\ n)$，更新节点的时间复杂度也是如此。

---

插入节点的方法：

按照二叉查找树寻找节点的方法找到将要插入的节点的父节点

然后在这个父节点的下面插入需要插入的新节点，并且将新插入的子节点初始化为红色

然后对新插入的子节点调用算法`insect_adjust(T,x)`

其中T指的是整个红黑树，x指的是新插入的节点

```c
insect_adjust(T,x)
{
	if(x 有一个红叔叔)
	{
		把x的爸爸和叔叔都涂黑;
    	令 z = x的爷爷;
    	把 z 涂红;
        insect_adjust(T,z)
	}
    else if(x 有一个黑叔叔)
    {
        令 y = x的爸爸;
        令 z = x的爷爷;
        令 p = z的爸爸;	 //(如果z有爸爸的话)
        				//(如果z原本就是根节点，那么z就没有爸爸)
        令 A = 以z为根的子树;
        令 m = x、y、z三个节点中既不是最大也不是最小的一个;
        修改x、y、z三个节点指向孩子节点的指针，使得满足以下三个条件
            1 m成为A子树的根
            2 其余两个节点成为m的孩子节点
            3 A仍然是一个二叉搜索树;
        为 x、y、z三个节点涂色，其中m为黑色，其余两个为红色;
        令 p 指向m;
    }
    if(x是根节点且x是红的)
    {
        把x涂黑;
        //这种情况是在一个空树中插入第一个节点；
        //单独一个黑色节点也是一个合法的红黑树；
        //因为红黑树要求根节点一定是黑色的；
    }
}
```

