---
layout: post 
category: SICP 
---

---

将简单的认识组合起来形成更复杂的方法：
$$
\left\{
	\begin{array}{}
		基本表达形式：语言所关心的最简单的个体\\
		组合的方法：通过他们可以从较简单的东西出发构造复杂的元素\\
		抽象的方法：通过它们为复合对象命名，并将它们当做单元去操作
    \end{array}
\right.
$$


lisp使用前缀表达式，适用于带有任意个实参的过程

```scheme
(+ 21 35 12 7)
```

合理的缩进有利于阅读表达式的含义

```scheme
#lang racket
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

使用`define`将名字与计算对象关联

```scheme
(define size 2)
```

组合式的求值

- 求值该组合式的各个子表达式
- 将作为最左子表达式（运算符）的值的那个过程用于相应的实际参数，所谓实际参数就是其他子表达式（运算对象的值）

求子表达式的过程是递归的

用树表示求值规则

每个组合式用一个带分支的节点表示，分支对应组合式里的运算符和各个运算对象。终端节点（即那些不再发出分支的节点）表示运算符或者数值。

求值过程就像数值沿着树向上穿行。--> **树形积累**

<img src="../../www/assets/pic/tmp-1.png" style="zoom: 50%;" />

上图对应的计算式为：

```scheme
#lang racket
(* (+ 2
      (* 4
         6))
   (+ 3
      5
      7))
```

复合过程：为复合操作提供名字，以后将这样的操作作为一个单元使用

规则：

```scheme
(define (<name> <formal parameters>) <body>)
```

例如定义平方

```scheme
(define (square x)(* x x))
```

上述的x是形式参数

过程应用使用代换模型。

完全展开而后归约：正则序

先求值参数然后应用：应用序(实际解释器使用)。能避免表达式的重复求值。对于超出可以采用替换方式模拟的过程范围后，正则序会变得复杂。

## 条件表达式和谓词

cond

```scheme
(define (abs x)
  (cond ((> x 0)x)
        ((= x 0)x)
        ((< x 0)(- x))))
(define (abs_if x)
  (if (< x 0)
      (- x)
      x))
```

复合逻辑运算符：and、or、not

```scheme
(define (>= x y)
  (or (> x y)(= x y)))
```

牛顿法求平方根（递归）

```scheme
#lang scheme
(define (square x)
  (* x x))
(define (abs x)
  (if (< x 0)
      (- x)
      x))
(define (good-enough? guess x)
  (< (abs (-(square guess) x)) 0.0000001))
(define (improve guess x)
  (/ (+ guess (/ x guess)) 2))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(sqrt 3)
```

输出

```scheme
1.7320508100147274
```

