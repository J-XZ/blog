---
layout: post
category: CSAPP
title: 虚拟内存
---

# Virtual memory Concepts

---

## 虚拟化

通过干预或介入对资源的访问实现资源的`虚拟化`。比如**磁盘**在物理上是由柱面、磁道、扇区、盘面构成的，事实上需要为上述物理位置分别指定编号 才能访问磁盘的具体位置。但是**磁盘控制器**通过拦截并处理来自操作系统的磁盘读写请求为操作系统提供了一个虚拟化的视图，将操作系统提供的逻辑块号转换为实际的物理地址。

---

## 虚拟内存

### Linear address space: Ordered set of contiguous non-negative integer addresses:

$$
\{0,1,2,3,\dots \}
$$

线性地址空间指的是一段连续的非负整数，表示地址的集合，而不是字节的集合

### Virtual address space: Set of $N=2^n$  virtual addresses

$$
\{0,1,2,3,\dots,N-1\}
$$

虚拟地址空间是包含 $ N=2^n $ 个虚拟地址的集合，是线性地址空间。所有进程虚拟地址空间相同

### Physical address space: Set of $ M=2^m $ physical  addresses 

$$
\{0,1,2,3,\dots,M-1\}
$$

物理地址空间对应系统中实际拥有的DRAM容量

### 虚拟内存的意义

#### 更有效率地使用主存。把主存当作虚拟内存的高速缓冲。一个缓冲块是一个页（一般4096字节，太小总是要换，太大换得太慢）。

![](../../www/assets/pic/1.png)

虚拟内存中有的块被实际加载到了内存，有的没有。甚至有的块还没有被分配实际的地址。

**CPU**生成虚拟地址，交给**MMU**(Memory Management  Unit)，MMU去页表(Page Table)查找。

页表是一个索引到值的映射表格。索引是虚拟地址，值是物理页的编号（如果这个物理页在内存中，即Page Hit）或者是一个指向硬盘(disk)地址的指针。

页表中的每一项成为一个**PTE**(Page Table Entry)

如果当前查找到的是一个指向硬盘(disk)地址的指针，CPU就会收到一个缺页中断。CPU处理缺页后会重新执行导致却页的指令。

全向联，每个页面可被缓存到任何位置。

如果工作集比主存空间大，就会导致**颠簸**（部分页面来回复制）

#### 简化进程的内存管理，每个进程都可以当作自己独占内存空间、在保证每个进程虚拟地址独立性的同时，又能实现共享库代码的共享。（只要让不同进程的页表指向同一个物理页即可）

每个进程有其独立的虚拟地址空间，他可以把虚拟地址空间看作一个简单的线性数组。通过操作系统为每个进程单独设置一个页表来实现。

![](../../www/assets/pic/2.png)

操作系统负责实现地址分配的映射

虚拟地址的同一个页面可能在不同的时间对应物理地址不同的位置（内存 中的页被换出到硬盘后再换入内存）

**简化了链接和加载**，链接器可以假设每个程序都加载到完全相同的位置，可以方便地知道每个段将要被加载到哪里。（链接器也不需要知道实际加载的不确定的物理地址位置）

加载器可以从固定的地址开始为代码和数据分配虚拟内存。

**加载器的trick**：看起来加载了，实际完全没加载，只有到程序读取内存引发缺页中断时，才会实际将页面从硬盘换到内存。**按需分页**，使得加载变得很高效，假设程序中有一个大数组，只访问其中一部分，那么只有那一部分需要被复制到内存中。

#### 分割进程的地址空间
##### 一个进程不能访问其他进程
##### 用户进程不能访问内核

