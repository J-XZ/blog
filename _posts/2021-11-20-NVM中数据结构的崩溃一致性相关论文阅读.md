---
layout: post 
category: papers 
---

Wang C, Wei Q, Wu L, et al. Persisting RB-Tree into NVM in a consistency perspective[J]. ACM Transactions on Storage (TOS), 2018, 14(1): 1-27.

介绍了在NVM上构建持久化的红黑树的算法。在非持久化红黑树的基础上，为每个节点的颜色、左孩子指针、右孩子指针设置两个版本，一个valid版本、另一个是shadow版本。相当于用一棵树的节点数量和两倍的指针数量用一棵树的节点构造了逻辑上的两棵树。每个节点拥有两个版本的颜色和孩子节点指针，为了表述方便，用0号版本和1号版本进行区分。每个节点用一个比特位作为内部版本标识，另外从他的父节点还有一个比特位作为外部版本标识。实际确定版本时，将一个节点的内部版本标识和外部版本标识**异或**，得到0或者1标识当前节点的valid版本是0号版本或1号版本。红黑树的根节点没有父节点，所以另外设置一个控制节点用两个版本的指针分别指向两棵逻辑树的根节点以及两个根节点的外部版本标识。

这样设计可以直接在shadow版本上对原树进行修改，然后只需要修改受到影响的子树根节点的版本标识，就可以将子树所有节点的valid版本和shadow版本的身份进行调换。（无需为全部节点修改版本标识，因为实际版本标识是随着版本计算的异或操作从一个节点向其孩子节点传递的）。

抽象来说，树中节点之间有指针连接而成的路径，而在树中查询就是沿着路径搜索，且路径是单向的。因为存在valid版本和shadow版本，所以搜寻到一个节点时不知道按照哪个版本的路径继续搜索。而通过来自父节点的外部版本标识，为进入节点赋予了一个状态，这个状态和当前节点自身的版本标识异或决定在当前节点应当按照哪个版本的路径继续搜索。原本的红黑树在每个节点仅仅通过需要检索的值来判定向左或右子树搜索，但是NVM持久化红黑树通过进入这个节点的父节点和这个节点自身共同判断应该使用哪个版本的指针进行检索。

---

传统的保证崩溃一致性的方法：

日志，缺点是两倍写。两种日志，redo日志是存储更新成功之后的数据版本，undo日志是保留更新成功之前的数据版本

log structured，缺点是寻找最新的版本并且有垃圾回收的开销

copy on write，缺点是写放大

---

Liu J, Chen S, Wang L. Lb+ trees: optimizing persistent index performance on 3dxpoint memory[J]. Proceedings of the VLDB Endowment, 2020, 13(7): 1078-1090.

总结了在NVM中保证数据崩溃一致性的方法：

- write ahead logging
- shadowing(就是copy on write)
- PMwCAS（Persistent Multi-Word Compare-and-Swap ）(Arulraj J, Levandoski J, Minhas U F, et al. BzTree: A high-performance latch-free range index for non-volatile memory[J]. Proceedings of the VLDB Endowment, 2018, 11(5): 553-565.)是一个提供多字节compare-and-swap操作的机制。首先在描述符缓冲区记录要修改部分的地址、旧值和新值。然后持久化描述符缓冲区。然后在每个目标字中写入并保存每个指向描述符缓冲区的指针。最后执行对目标字的实际写入。PMwCAS 可用于实现数据结构的数据持久化和无锁存操作。https://github.com/microsoft/pmwcas 。
- NVM atomic writes (NAW)

![image-20211120212638064](../../www/assets/pic/image-20211120212638064.png)

首先设置一个标记字$D$，$U_1$、$U_2$、$U_3$是三个需要被原子化写入的字，NAM的操作方式就是先确保这三个字写入，然后显式刷到NVM，然后用sfence确保上述操作全部被执行完毕，之后更新标记字$D$为$D'$。如果发生崩溃，恢复时检查D，如果查到旧D值就把$U_1$、$U_2$、$U_3$当作空白位置；如果查到$D'$就可以保证$U_1$、$U_2$、$U_3$被写入成功。这个方法有非常大的局限性，D最大是一个cacheline大小，如果D的大小不足以记录$U_1$、$U_2$、$U_3$的位置（要写入的位置非常多），就必须用多组NAW操作模拟一个大的NAW操作。

